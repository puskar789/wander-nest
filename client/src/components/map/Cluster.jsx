import React, { useEffect, useState } from "react";
import useGlobal from "../../zustand/useGlobal";
import useGetRooms from "../../hooks/useGetRooms";
import ReactMapGL, { Marker } from "react-map-gl";
import Supercluster from "supercluster";
import { useAuthContext } from "../../context/AuthContext";
import Geocoder from "../sidebar/Geocoder";
import PopUp from "./PopUp";

// A radius of 75 pixels means that any points within a circle of 75 pixels will potentially be grouped into a cluster.
// If the map is zoomed in close enough (e.g., zoom level 21), points that were previously grouped into a cluster will now be displayed as separate markers
const supercluster = new Supercluster({
  radius: 75,
  maxZoom: 20,
});

const Cluster = () => {
  const { filteredRooms } = useGlobal();
  const { mapRef } = useAuthContext();
  const { getRooms } = useGetRooms();

  // Each point (room) is formatted as a GeoJSON Feature, which is required by Supercluster.
  const [points, setPoints] = useState([]);
  // Stores the clusters generated by Supercluster.
  const [clusters, setClusters] = useState([]);
  // Stores the geographical bounds of the current visible area on the map.
  // Bounds are used by Supercluster to determine which points fall within the visible region and need clustering.
  // [-100, -85, 100, 85] is a placeholder value representing a wide area on the map.
  const [bounds, setBounds] = useState([-100, -85, 100, 85]);
  // The zoom level determines the granularity of the clustering:
  // At lower zoom levels, points are grouped into fewer, larger clusters.
  // At higher zoom levels, clusters break into smaller clusters or individual points.
  const [zoom, setZoom] = useState(0);

  useEffect(() => {
    const fetchRooms = async () => {
      await getRooms();
    };

    fetchRooms();
  }, []);

  // Transforms the raw rooms data into a format required by the Supercluster (GeoJSON features)
  useEffect(() => {
    // console.log(rooms);
    const points = filteredRooms.map((room) => ({
      type: "Feature",
      properties: {
        cluster: false, // means it is not a cluster i.e. it is a single room
        _id: room._id,
        price: room.price,
        title: room.title,
        description: room.description,
        longitude: room.lng,
        latitude: room.lat,
        images: room.images,
        userPhoto: room.userPhoto,
        userName: room.userName,
      },
      geometry: {
        type: "Point",
        coordinates: [parseFloat(room.lng), parseFloat(room.lat)],
      },
    }));
    setPoints(points);
  }, [filteredRooms]);

  useEffect(() => {
    supercluster.load(points);
    setClusters(supercluster.getClusters(bounds, zoom));
  }, [points, zoom, bounds]);

  useEffect(() => {
    if (mapRef?.current) {
      setBounds(mapRef.current.getMap().getBounds().toArray().flat());
    }
  }, [mapRef?.current]);

  return (
    <div className="w-full">
      <ReactMapGL
        initialViewState={{ longitude: 51.5072, latitude: 0.1275, zoom: 0.9 }}
        mapboxAccessToken={import.meta.env.VITE_MAP_TOKEN}
        mapStyle="mapbox://styles/mapbox/streets-v11"
        ref={mapRef}
        onZoomEnd={(e) => setZoom(Math.round(e.viewState.zoom))}
      >
        {clusters.map((cluster) => {
          const { cluster: isCluster, point_count } = cluster.properties;
          const [longitude, latitude] = cluster.geometry.coordinates;

          // getClusterExpansionZoom calculates the optimal zoom level for the cluster expansion. It tries to fit all the points in the cluster at the best zoom level.
          if (isCluster) {
            return (
              <Marker
                key={`cluster-${cluster.id}`}
                longitude={longitude}
                latitude={latitude}
              >
                <div
                  className="text-white bg-blue-600 rounded-full flex justify-center items-center p-7"
                  style={{
                    width: `${10 + (point_count / points.length) * 20}px`,
                    height: `${10 + (point_count / points.length) * 20}px`,
                  }}
                  onClick={() => {
                    const zoom = Math.min(
                      supercluster.getClusterExpansionZoom(cluster.id),
                      20
                    );
                    mapRef.current.flyTo({
                      center: [longitude, latitude],
                      zoom,
                      speed: 1,
                    });
                  }}
                >
                  {point_count}
                </div>
              </Marker>
            );
          }

          return (
            <Marker
              key={`room-${cluster.properties._id}`}
              longitude={longitude}
              latitude={latitude}
            >
              <PopUp room={cluster.properties}>
                <div className="avatar">
                  <div className="w-12 rounded-full">
                    <img src={cluster.properties.userPhoto} />
                  </div>
                </div>
              </PopUp>
            </Marker>
          );
        })}
        <Geocoder />
      </ReactMapGL>
    </div>
  );
};

export default Cluster;

/*
Dependency Array: [points, zoom, bounds]
This useEffect runs whenever one of the following changes:
points: The list of room data transformed into GeoJSON features.
zoom: The zoom level of the map.
bounds: The visible area of the map, expressed as a bounding box (northwest and southeast corners).
What It Does:
supercluster.load(points):
This method loads the array of points (GeoJSON features) into the Supercluster instance for clustering.
It essentially prepares the data for clustering based on the map's current bounds and zoom level.
setClusters(supercluster.getClusters(bounds, zoom)):
This fetches the current clusters based on the bounds of the map and the zoom level.
getClusters(bounds, zoom):
Takes two parameters:
bounds: The geographic bounds of the currently visible map area (latitude and longitude coordinates of the northwest and southeast corners).
zoom: The current zoom level of the map.
It returns an array of clusters and individual room features, which is then stored in the clusters state using setClusters.
Purpose:
This effect ensures that the clusters are updated whenever the map's points, zoom, or bounds change.
The points are reloaded into Supercluster, and the new clusters are recalculated and stored in clusters.


Dependency Array: [mapRef?.current]
This useEffect runs whenever the mapRef.current changes. It’s essentially waiting for the map component to be mounted.
What It Does:
if (mapRef?.current):

Checks if mapRef.current is defined and refers to the map object (the map component created by ReactMapGL).
This check ensures that the map is available before attempting to get its bounds.
setBounds(mapRef.current.getMap().getBounds().toArray().flat()):

mapRef.current.getMap(): Gets the underlying Mapbox map instance from the mapRef.
getBounds(): Returns the geographical bounds (latitude and longitude) of the currently visible area of the map.
The result is an object containing the SW (southwest) and NE (northeast) corners of the visible map area.
toArray(): Converts the bounds object into an array of the corner coordinates.
flat(): Flattens the nested array to get a simple array of 4 values: [minLng, minLat, maxLng, maxLat].
This ensures that the bounds are in the correct format for Supercluster to use.
setBounds():

Updates the bounds state with the current visible map area. This triggers the first useEffect hook, which will then update the clusters.
Purpose:
This effect keeps track of the map’s visible bounds, so that Supercluster can recalculate clusters based on the portion of the map the user is currently viewing.
How the Code Works Together:
The second useEffect keeps the bounds of the visible map up to date whenever the mapRef.current changes (i.e., when the map is initialized or moved).
The first useEffect uses the updated bounds, along with the zoom level and the points data, to load the data into Supercluster and recalculate the clusters.
As a result:

When the user pans or zooms the map, the bounds change, triggering the second effect to update the bounds.
This, in turn, triggers the first effect to update the clusters, ensuring that the map always displays the correct clusters for the visible area and zoom level.

so if we don't zoom on the map but we just slide the map towards the right/left will this run?
ChatGPT said:
ChatGPT
No, sliding the map (panning) towards the right or left will not trigger the second useEffect.
*/
